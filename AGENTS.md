# Repository Guidelines

## Project Structure & Module Organization

The Next.js App Router lives in `src/app`, with route groups mirroring public paths (e.g., `src/app/about/page.tsx`). Shared UI and hooks sit in `src/components` and `src/lib`, while MDX-driven content is stored under `src/markdown`. Static assets belong in `public`, long-form docs live in `docs`, and browser assets generated by Playwright are written to `test-results`. Use the `@/` alias (configured in `tsconfig.json`) instead of relative `../../` chains for internal imports.

## Build, Test, and Development Commands

Use pnpm for all workflows. `pnpm install` resolves workspace dependencies. `pnpm dev` launches Next.js with Turbopack at `http://localhost:3000`. `pnpm build` performs a production build, and `pnpm start` serves the compiled output—use this combo to verify deployment readiness. `pnpm lint` runs the root `eslint.config.mjs` ruleset; fail-fast here before opening a PR.

## Coding Style & Naming Conventions

The repo targets strict TypeScript, so annotate props, return types, and Supabase helpers explicitly. Favor server components unless a hook or browser API forces "use client". Components and hooks use PascalCase and camelCase respectively, route segments remain kebab-case. Tailwind v4 powers styling: prefer tokens defined in `tailwind.config.ts` and co-locate utility-heavy snippets in small components to keep `app` routes readable. Let ESLint flag formatting issues instead of hand-tuning.

## Testing Guidelines

End-to-end checks live in `tests/*.spec.ts` and run through Playwright (`pnpm exec playwright test`). Name specs after the route they cover and keep scenarios independent—mock Supabase via fixtures rather than live calls. If you add UI that depends on viewport states, capture assertions via `expect.poll` to avoid race conditions. CI requires green e2e plus lint, so run both locally before pushing.

## Commit & Pull Request Guidelines

Follow the conventional commit prefix used in history (`feat:`, `docs:`, `refactor:`, etc.) plus an imperative summary, e.g., `feat: add mdx speaker cards`. Each PR should describe the problem, the solution, and any visual changes (attach screenshots or recordings for layout updates). Link tracking issues when available and call out new environment variables or migrations so reviewers can test safely.

## Security & Configuration Notes

Supabase keys, analytics tokens, and similar secrets belong only in `.env.local`; never commit them. If a change touches authentication or middleware, outline the threat model in the PR and note any manual steps (e.g., rotating service roles) required after deploy.

## CI/CD Guidelines

A minimal CI/CD pipeline lives under `.github/workflows/`. It should:

* run on pushes to `main` and on pull requests
* install dependencies using pnpm
* run `pnpm lint` and `pnpm exec playwright test`
* build the project (`pnpm build`)

Artifacts from successful builds should be uploaded using the GitHub Actions artifact system. For local or remote deployment, a shell script (e.g., `scripts/deploy.sh`) can fetch the latest artifact via GitHub CLI, replace the deployed files, and restart the runtime process. Pipelines should remain simple and script-driven; avoid overengineering unless multiple environments require separate workflows.
